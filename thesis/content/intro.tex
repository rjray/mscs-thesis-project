\section{Introduction}
\label{sec:introduction}

When evaluating a programming language for use on a project, we as programmers are faced with an ever-growing array of choices. These choices range from long-lived, well-established languages such as C or Fortran, to the very latest offerings such as Julia or Swift. Selecting a language is a process that is generally rooted in a combination of factors: suitability to the target platform, performance, expressiveness, and (often most importantly) the programmer's familiarity and comfort with the language.

This thesis will be a comparison of the relative strengths of five different programming languages when applied to identical problems. To explore this, the problem of large-scale string matching will be examined with a focus on matching within DNA-like strings.

\subsection{String Matching}

The topic of string matching has long been a popular area of research in computer science. Before the paper by Knuth, Morris and Pratt in 1977~\cite{knuth.morris.pratt.1977} there was already considerable work being done. In the same year, Boyer and Moore~\cite{boyer.moore.1977} published an improvement over the Knuth-Morris-Pratt algorithm with enhancements such as starting the match from the tail of the pattern rather than the head, and allowing for greater right-ward jumps through the string being searched.

But string matching means extensive reading and manipulation of strings. These strings are blocks of allocated memory, which can lead to program errors and vulnerabilities. A large percentage of security vulnerabilities discovered in programs are traced back to memory-related issues; in~\cite{cimpanu.2020}, Google software engineers are quoted as attributing roughly 70\% of serious security bugs in Chrome to memory management and safety bugs. The article goes on to report that analysis from Microsoft echoes this number. As such, a process to write programs that are more stable and secure must include careful consideration of memory-related challenges.

\subsection{DNA Strings}

For this study, string matching will be applied to the problem of finding sub-sequences within DNA strings. DNA sequence strings have some interesting properties, in that they can be \textit{extremely} long but at the same time the alphabet is limited to just four characters (``A'', ``C'', ``G'' and ``T'').

As Heather and Chain put it in~\cite{heather.chain.2016}, ``It is hard to overstate the importance of DNA sequencing to biological research''. Today's researchers use ever-increasing computing resources to process this data faster and in a more complete fashion. String-matching algorithms, mathematical models and other tools have become vital to these research fields, as the size and quantity of data produced by sequencing has grown. In just the two decades since the completion of the Human Genome Project, current sequencer technology has advanced to the point of being capable of producing a terabyte of data per day.

\subsection{Comparison Bases}
\label{subsec:comparison}

Solutions to the problem will be developed in five languages: C, C++, Rust, Perl, and Python. Each language's solutions will be evaluated against the others on three bases:

\begin{enumerate}
\item \textbf{Execution speed}: Overall run-times for each solution will be gathered using existing timer mechanisms. Time-measurements will be somewhat coarse, as overhead operations such as I/O will necessarily be included in the times.
\item \textbf{Readability and expressiveness}: Each solution will be measured on several source-level metrics in an effort to evaluate the expressiveness and clarity of the code.
\item \textbf{Energy efficiency}: Energy usage will be measured for each solution using the Running Average Power Limit (RAPL) tools available on Intel processors. RAPL will be outlined in greater detail in section~\ref{subsubsec:rapl}.
\end{enumerate}

These three bases cover modern concerns in software development: the general performance of an application, the readability/maintainability of the application, and the power consumption of the system running the application. Where the first two criteria are well-known and common, the last has been chosen based on steadily-growing concern over power consumption in the data center industry and in the mobile computing field~\cite{pereira.et.al.2017}.
