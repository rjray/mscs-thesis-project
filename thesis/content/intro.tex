\section{Introduction}
\label{sec:introduction}

When evaluating a programming language for use on a project, we as programmers are faced with an ever-growing array of choices. These choices range from long-lived, well-established languages such as C or Fortran, to the very latest offerings such as Julia or Swift. Selecting a language is a process that is generally rooted in a combination of factors: suitability to the target platform, performance, expressiveness, and (often most importantly) the programmer's familiarity and comfort with the language.

This thesis will be a comparison of the relative strengths of the Rust programming language when compared to C/C++. To explore this, the problem of large-scale string matching will be examined with a focus on matching within DNA strings.

\subsection{String Matching}

The topic of string matching has long been a popular area of research in computer science. Before the paper by Knuth, Morris and Pratt in 1977~\cite{knuth.morris.pratt.1977} there was already considerable work being done. In the same year, Boyer and Moore published an improvement over the Knuth/Morris/Pratt algorithm with enhancements such as starting the match from the tail of the pattern rather than the head, and allowing for greater right-ward jumps through the string being searched~\cite{boyer.moore.1977}.

But string matching means extensive reading and manipulation of blocks of allocated memory, which can lead to program errors and vulnerabilities. A large percentage of security vulnerabilities discovered in programs are traced back to memory-related issues; in~\cite{cimpanu.2020}, Google software engineers are quoted as attributing roughly 70\% of serious security bugs in Chrome to memory management and safety bugs. The article goes on to report that analysis from Microsoft echoes this number. As such, a process to write programs that are more stable and secure must include careful consideration of memory-related challenges.

\subsection{DNA Strings}

For this study, string matching will be applied to the problem of finding sub-sequences within DNA strings. DNA sequence strings have some interesting properties, in that they can be \textit{extremely} long but at the same time the alphabet is limited to just four characters (``A'', ``C'', ``G'' and ``T''). The limited alphabet may prove useful for optimizations in the code developed for comparison of the solutions.

\subsection{Comparison Bases}

Solutions to the problem will be developed in three languages: C, C++, and Rust. Each language will be evaluated against the others on three axes:

\begin{enumerate}
\item Execution speed (``performance''): Overall run-times for each solution will be gathered using existing timer mechanisms. Time-measurements will be somewhat coarse, as overhead operations such as I/O will be included in the times.
\item Readability and expressiveness (``perspicuity''): Each solution will also be measured on several source-level metrics in an effort to evaluate the expressiveness and clarity of the code.
\item Energy efficiency (``power''): Energy usage will be measured for each solution using the Running Average Power Limit (RAPL) tools available to Intel processors.
\end{enumerate}

These three bases cover modern concerns in software development: the general performance of an application, the readability/maintainability of the application, and the power consumption of the system running the application. This last basis is used because concern over power consumption has been steadily growing in the data center industry and in the mobile computing field~\cite{pereira.et.al.2017}.
