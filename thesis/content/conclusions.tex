\section{Conclusions}
\label{sec:conclusions}

In choosing the three diverse metrics to measure on, the goal was to provide an environment in which any of the five languages would have the chance to stand out. In this regard the research can be considered successful: each of the five languages managed to be at least as high as the \nth{2} position in at least one metrics table.

An earlier incarnation of this work had focused on the security benefits of the Rust language. Through the process of research and running of the experiments, the focus changed to that stated in the abstract: finding the best language for bioinformatics based on a balance of these three distinct metrics.

And, in the end, that language appears to be Rust.

Over the three bases that were reviewed, Rust clearly stood out in performance and energy. The measure of expressiveness is the only area in which it was not in the top place of the table. That said, expressiveness is the most subjective of the measurements and Rust could well improve in this measure through broader utilization and its own evolution.

Whether this establishes Rust as the ``best'' language for this purpose cannot be said for certain, for the definition of ``best'' can only be objective up to a point before subjective judgment and feelings begin to influence decisions. In the end, the measurements taken and evaluated began to somewhat resemble the concept of a triathlon: it was not necessary for Rust to win every category to have ended up as the recommended solution, the overall winner. Rust did not even achieve notable performance metrics, only being the top-ranked for one of the six algorithms. But Rust's performance numbers were steady and reliable across all algorithms. In terms of energy usage Rust was top-ranked in fully half of the algorithms and variations. This lead to Rust leading both of these metrics in the final results.

Recently, ZDNet published an article~\cite{tung} about the National Security Agency's recommendation for developers to consider switching to programming languages that feature greater memory safety. While memory safety was not a primary focus of this research, it is noteworthy that the recommended language is also considered to be the safest in this regard. All of the experiments written in compiled languages were tested with Valgrind, being refined and debugged until Valgrind reported no memory-related errors detected\footnote{Perl and Python were not tested with Valgrind, as they are built on bytecode interpreters whose memory-safety is a separate issue.}. Of the compiled languages, only Rust never exhibited any memory errors through Valgrind.

With this, it becomes more understandable why Perkel~\cite{nature} found so many in the sciences turning to Rust as their choice of a performance-oriented language. Though the youngest of the languages evaluated here, Rust has quickly grown to showing great potential for a wide range of applications. As the collected results show, it is not necessary to dominate every metric in order to come out on top: steady and reliable performance, be it raw speed or good energy management, can carry one to the winning position.
